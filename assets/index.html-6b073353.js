import{_ as s,M as a,p as d,q as h,R as t,N as n,V as i,t as e}from"./framework-5866ffd3.js";const c={},l=t("h1",{id:"sisters-wudilib",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#sisters-wudilib","aria-hidden":"true"},"#"),e(" Sisters.WudiLib")],-1),_=t("h2",{id:"介绍",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#介绍","aria-hidden":"true"},"#"),e(" 介绍")],-1),u=t("p",null,"妹妹无敌库（Sisters.WudiLib）是 C# 乃至 .NET 下的 OneBot SDK，实现 .NET 平台进行 OneBot 协议通信。",-1),f=t("h2",{id:"写在前面",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#写在前面","aria-hidden":"true"},"#"),e(" 写在前面")],-1),p=t("p",null,"我从 2018 年初开始制作这个通信库。当时还是酷 Q 时代，COOLQ-HTTP-API 还是 3.4 版本。那时候还完全没有 C# 的 SDK，于是我就写了 WudiLib。一转眼几年过去，酷 Q 永远离开了我们，但 COOLQ-HTTP-API 进化成了 OneBot 协议，生态也繁荣起来。光是 C# 写的 SDK 就有好几个。我一直希望能有现成的 SDK 用，因为我一度不想把这个 SDK 维护下去了。但是，现有的几个其他 SDK 质量实在无法令我满意。各个开发者一遍又一遍地采用早就被我废弃的不良设计，甚至部分想当然的设计让我怀疑其开发者是不是在写 bot。于是，我就只好把 WudiLib 继续更新下去。",-1),b={href:"https://github.com/dotnet/runtime",target:"_blank",rel:"noopener noreferrer"},m={href:"https://github.com/dotnet/aspnetcore",target:"_blank",rel:"noopener noreferrer"};function S(x,L){const o=a("RouterLink"),r=a("ExternalLinkIcon");return d(),h("div",null,[l,_,u,t("p",null,[n(o,{to:"/zhinan/kuaisushangshou.html"},{default:i(()=>[e("快速上手")]),_:1})]),f,p,t("p",null,[e("诚然，由于历史原因，WudiLib 也包含许多可以改进的设计。您有很大概率对 WudiLib 也不满意，因为我也是。我将在"),n(o,{to:"/lantu.html"},{default:i(()=>[e("蓝图")]),_:1}),e("中描述我心目中理想的 C# OneBot SDK 和框架应该是什么样子的。我也强烈建议每个想自己开发 SDK 或框架的开发者读一读我"),n(o,{to:"/gei-sdk-kaifazhedejianyi.html"},{default:i(()=>[e("给 SDK 开发者的建议")]),_:1}),e("。希望早日见到质量媲美 "),t("a",b,[e(".NET runtime"),n(r)]),e(" 的 SDK，和质量媲美 "),t("a",m,[e("ASP.NET Core"),n(r)]),e(" 的框架。")])])}const D=s(c,[["render",S],["__file","index.html.vue"]]);export{D as default};
